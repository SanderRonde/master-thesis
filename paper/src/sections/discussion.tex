\chapter{Discussion}\label{chap:discussion}

\section{Discussion of Results}
The results described in Chapter~\ref{chap:results} show that the creation of a UI library from an existing codebase is very well possible in an Angular application. Render times are only slightly higher, remaining competitive with various other UI libraries. One negative aspect seems to be that the render times increase pretty quickly with a higher number of components. Further, load times are not significantly higher in all cases except the Angular wrapper. This should result in a good user experience across the board, being slightly slower than the original components but providing access to them in the most popular JS frameworks. We can say that the answer to RQ1 is that it is definitely technically feasible to migrate Angular components to Web Components.

While the technical results of this project are important, we also evaluated the business side of this project. We find the time spent to be five months of FTE\@. We also took a look at the degree to which this project interferes with the original codebase and its developers' workflows through a questionnaire answered by the three front-end developers at 30MHz. It should be noted that of the three front-end developers, two indicate they only work on the front-end once a week or less. Additionally, the third front-end developer had recently joined the company and has not witnessed the complete development process described in this paper. As such, we are unable to draw definitive conclusions from the results of the questionnaire, and we instead treat the results as mere indications.

In questioning these three front-end developers at 30MHz, we found that, on average, they rated the impact of changes to the main codebase as a 2.6 on a scale from 0 (no impact at all) to 10 (significant impact). For a process that interlocks with the main codebase so heavily, this is a very low number, leading us to believe that the impact was slim.
Additionally, there are some new factors that developers have to keep in mind while developing new components. An example of this is the need for better documentation for components in order to ensure the automatically generated documentation is correct. Another example would be the need to add a new UI component to the array containing all components that are to be included in the UI library. On average, the developers rated the impact of these changes to be a 2, signaling that the everyday impact is not very large. Lastly, we asked developers how often the existence of this project blocked their workflow. They all indicated they had not been blocked once, meaning this project was executed entirely without blocking other developers' workflow. These results suggest that the business viability of the migration of Angular components to a UI library is relatively high as well, leading to minimal impact on current developers and their workflow while requiring relatively little time. Especially in a situation where there are many UI components, the time spent on this project is significantly smaller than the time spent recreating them.

All in all, we can conclude that the answer to RQ1 is that the process of migrating Angular components to a Web Component UI library is feasible. We hope this case study convinces businesses who are considering this process to take the steps we have taken over creating an entirely new UI library. In addition to being used in the manner we described, that is, the creation of a UI library for third parties, this process could also be applied to components that are internal to a business. With the ever-increasing amount of platforms with which users are able to interact (desktops, phones, tablets, televisions, smart fridges), the number of platforms for which businesses need to develop an application also increases. Since most of these platforms require different software stacks, Web Components could provide a basis for generating components for other platforms. For example, the main large web app can be built in Angular, with another small internal web app being built in React (using the React wrapper), another internal web app built in Vue, and the mobile apps built using React Native~\footurl{https://reactnative.dev/} or Apache Cordova~\footurl{https://cordova.apache.org/}.

What the results of this study do not tell us is the viability of migrating components from any other JS framework to Web Components. In this case study, we specifically targeted Angular, which provides the simple Angular Elements tool~\footurl{https://angular.io/guide/elements}. Other JS frameworks might not have such tools available, which might make this process less straightforward. However, we believe that the process of migrating components from any other popular JS framework to Web Components may very well be significantly easier than from Angular components. A large number of the issues we faced were Angular related, as described in Section~\ref{sec:case-study:ng-deep}. Those issues were also by far the hardest to solve. Most of these issues would not appear when using other JS frameworks.

\section{Checklist for Migration to Web Components}
Based on the work performed in Chapter~\ref{chap:case-study} we present a checklist going over the various steps required to perform a migration to Web Components. Note that this checklist contains the steps likely to be required for conversion to Web Components in a general sense and not the conversion specifically from Angular. In order to aid in the use of the checklist, we include hints about how the described steps have been tackled in the presented case study.

\subsection{Checklist}
\begin{enumerate}
	\item \textbf{Rendering components}\\
	      \textbf{Description:} Wrap the individual components in Web Components that render them to the DOM. When completed successfully, appending a given HTML tag to the DOM such as \code{<x-button>} should render the corresponding component from the original set of components. This process will differ from JS framework to JS framework but will generally come down to the following steps:
	      \begin{enumerate}
		      \item Iterate over every component in the set of original components
		      \item Register a new Web Component for every component with the task of rendering that component. Choose a tag name under which to register this Web Component as a Custom Element.
		      \item When rendering this Web Component, append a new ShadowRoot to it in the DOM.
		      \item To this ShadowRoot append a rendering root in whichever JS framework is being used.
		      \item Append the to-be-rendered component to the rendering root of the target JS framework.
	      \end{enumerate}
	      \textbf{Reference Solution:} In the case of Angular, this step is almost entirely taken care of by Angular Elements. This is also the approach we used to solve this problem.
	\item \textbf{Compatibility (optional)} \\
	      \textbf{Description:} While browser support for Web Components is relatively widespread, it is not yet supported by every browser and every browser version. Depending on the browsers that need to be supported, polyfills might be needed to add support for unsupported features. An overview of browser support for Web Components can be found on \emph{caniuse.com}~\footurl{https://caniuse.com/?search=components}.\\
	      \textbf{Reference Solution:} As described in Section~\ref{sec:case-study:compatibility}, we make use of polyfills to add support for Web Components for those browsers that do not already support it. In particular we make use of the \ver{custom-elements}\footurl{https://www.npmjs.com/package/@ungap/custom-elements} and \ver{custom-elements-builtin}\footurl{https://www.npmjs.com/package/@ungap/custom-elements-builtin} polyfills.
	\item \textbf{Global CSS application} \\
	      \textbf{Description:} Generally styles are applied to components through a global stylesheet. Wrapping components in ShadowRoots will cause this global stylesheet to no longer apply to them, effectively removing any styling from them. \\
	      \textbf{Reference Solution:} We solve this issue by injecting this global stylesheet into every ShadowRoot, making use of \code{adoptedStylesheets} to reduce performance impact of this approach. A more detailed description of our approach can be found in Section~\ref{sec:case-study:global-css}.
	\item \textbf{Application of Complex Attributes (optional)} \\
	      \textbf{Description:} Most JS frameworks allow the passing of complex JS values to components through attributes. This is in contrast to Web Components, which only allow the passing of string values to components through HTML attributes. This problem is described in-depth in Section~\ref{sec:case-study:complex-attributes}. Note that this problem may no longer be required when support for Web Components is completed in all major JS frameworks. The state of support for Web Components can be found on the website \emph{custom-elements-everywhere.com}~\footurl{https://custom-elements-everywhere.com/}. If the migrated components do not need complex attributes and work with string attributes as well, this step can be skipped. \\
	      \textbf{Solution:} Our solution to this problem is described in Section~\ref{sec:case-study:complex-attributes} as well. Essentially, we create wrappers for three of the largest JS frameworks that wrap around the created Web Components. The wrappers for these components then facilitate the use of complex attributes by applying the complex attributes they receive directly to the original component instance that is rendered inside of the Web Component.
\end{enumerate}