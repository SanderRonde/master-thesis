\chapter{Results}\label{chap:results}
As described in Chapter\ref{chap:design}, we have collected a number of metrics. Using these metrics, we are able to compare the CC UI library to the original Angular components, the various JS framework wrappers, and various other UI libraries. In the following sections we will break down the various metrics and compare the results between the various libraries.

\section{Render Time}
The render time metric will allow us to evaluate the direct performance impact on users once the page has loaded. We will firstly compare the CC UI library to the original Angular components as well as the other JS framework wrappers. This wil allow us to evaluate the performance impact added by the process of conversion to Web Components, as well as the performance impact added by the JS framework wrappers. After this, we will compare the CC UI library to the UI libraries listed in Table~\ref{tab:design:ui-libraries}, allowing us to evaluate the performance of the CC UI library relative UI libraries as a whole.

\subsection{Cow Components}
Looking at the performance of the CC UI library compared to the original Angular components, we find a very small performance impact, coming in at only~\todo{performance impact ms}. From this we can conclude that, although there is a full Angular root running for each component, the performance impact is minimal.

\todo{Is it still true that svelte and react are the same and Angular is the worst?}
\todo{Add a figure}
We find that the performance render times of the various JS frameworks differ a lot. The Svelte and React wrappers appear to be the fastest, while the Angular wrapper is significantly slower. We will take a look at whether this performance difference is also preset in other UI libraries in the next section.

\subsection{UI Libraries}
We now compare the render times of the various UI libraries. We first of all find that there are large differences in render times even within UI libraries that share the same framework. In most cases this has to do with the libraries themselves, but in a few cases this has to do with the type of library. These libraries (\ver{react-bootstrap}, \ver{ng-bootstrap}, and \ver{ngx-bootstrap}) make use of a CSS framework. The idea of a CSS framework is to put most all of the styles a developer will need in a single CSS file. This includes the various variations they could need. For example a CSS library could include the \code{.padding-5} selector as well as the \code{.padding-2} selector for setting the padding of a component. Note that the number of pixels of this padding is included in the selector. This generally leads to relatively big CSS files, which may or may not be treeshaken. This is in contrast to pure UI libraries which generally use per-component stylesheets instead of global stylesheets. They also tend to shift numbers and sizes to JavaScript or HTML\@. For example the same padding as above could be applied through a property, i.e. \code{<my-component padding="2"/>} or \code{<my-component padding="5"/>}. This approach has the advantage of a more per-component focus, more flexibility and options that are easier to discover. However, compared to UI libraries that make use of a CSS framework, normal UI libraries are significantly slower. The UI libraries that make use of a CSS framework generally only append an element to the DOM and apply some pre-computed set of classes to them, meaning they only interact with the very fast JavaScript APIs that are native to the browser. Normal UI libraries on the other hand generally have to run a lot more code.

\todo{Take a look at the average render time of the other UI libraries, are we faster than the average?}
\todo{Is this still true? Also add Vue}
\todo{Also check out the 10-component and 100-component renders}
When we ignore these outliers, we can draw some conclusions the average render times of the various frameworks. We can see that Svelte UI libraries are generally very fast. This falls in line with various other performance benchmarks on the internet~\footurl{https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html}. After this, the UI libraries using Web Components are the fastest. It is quite interesting that these are slower than UI libraries using Svelte since Web Components are a native technology, leading one to believe that they would be faster. This might have something to do with the ways in which the authors of the UI libraries created their Web Components. It could be that their approach imposes a significant performance impact. The next frameworks when it comes to render time performance are Angular and React. They are quite close in performance, both being significantly slower than other frameworks. This is again supported by other performance benchmarks on the internet.

We now apply our findings to the CC UI library JS framework wrappers. We find that the performances of our wrappers do not deviate from the general trend we just found. In our case the Web Components version is the fastest simply because every other wrapper builds on top of this version. This means that it is basically impossible for another framework to be faster than it. As expected, the Svelte wrapper is fastest. Interestingly however, the React wrapper is only slightly slower than the Svelte wrapper, while the Angular wrapper is significantly slower than the both of them. This is in contrast to what we just found, where both Angular and React were slow. It could be that the various internals of React that keep track of state and properties are slow. These are likely to be used a lot by regular React UI libraries which need to handle their state entirely in React, while our React wrapper simply renders a component and passes it its properties once.

\section{Load Time}
The load time metric will allow us to evaluate the initial performance impact of the CC UI library. Again, we will be comparing the various wrappers to each other as well as the original Angular components.

\subsection{Cow Components}
\todo{Revisit once the -basic results are in}
\todo{Add graph}
When we compare the load time of the CC UI library to the load time of the original 30MHz dashboard, we find that the CC UI library is significantly slower. This is likely because the 30MHz dashboard has been optimized specifically for the initial load time. It loads the minimum amount of JavaScript needed to render the page. After this, other files are only loaded on an as-needed basis. The CC UI library on the other hand has to be contained in a single file. Splitting it up into multiple files and instructing 3rd party developers to have multiple JS bundles just to make the CC UI library work would be a terrible developer experience. Concatenating the files into a single big bundle means all of the code has to be parsed and executed, slowing down execution by quite a lot. Comparing the various wrappers to each other, we can first of all see that both the React and Svelte wrappers are just slightly slower than the CC UI library. The added load time is likely to be added by the JS frameworks themselves. Finally, we can see that the Angular wrapper is by far the slowest. This is not entirely unexpected. As mentioned in Section~\ref{sec:case-study:ivy}, we had to disable AOT compilation for the Angular wrapper. This means all Angular compilation happens in the browser instead of during the compilation of the JS bundle. This is likely to be the reason why the Angular wrapper is so slow.

\subsection{UI Libraries}
\todo{Mention Vue}
Other UI libraries largely differ in load time as well. We can first of all see that Svelte UI libraries are by far the fastest, followed closely by Web Components UI libraries. After this, React UI libraries are the fastest. Finally we have Angular, which is by far the slowest. Interestingly, we can see that the different distributions of multi-framework UI libraries follow this same pattern. For example the \ver{prime-ng} UI library is significantly slower than the \ver{prime-react} UI library. Similarly, \ver{onsen-angular} is significantly slower than \ver{onsen-react} and \ver{onsen-web-components}. This could also be one of the factors that is causing our Angular wrapper to be slower, although the lack of AOT compilation is still by far the most influential factor.

\section{Bundle Size}
Bundle size is a more abstract representation of the previous metric, allowing us to take a look at the impact of just the bundle size itself. This excludes any performance impact that can be attributed to poorly optimized code. This will also allow us to look at what the performance impact of the Angular wrapper would be if there was no issue with AOT compilation.

\todo{Mention Vue}
We can first of all see that the bundle sizes correlate strongly with the load times. From this we can conclude that they are a very good representation of the load time metric. We can again see that Svelte and Web Component UI libraries are the smallest, with React following closely after them and with Angular being by far the biggest. This is also visible in our various wrappers. The Angular wrapper is by far the biggest. With the strong correlation between load time and bundle size we can conclude that a large part of the Angular wrapper's slow load time can be attributed to the large bundle size.

\section{Page Load Time}
\todo{Waiting for data}


\section{Quality of Web Components}
\todo{Write about the quality of the CC UI library compared to other UI libraries. Waiting for data}

\section{Time spent on the project}\label{sec:results:time-spent}
While the technical results of this project are important, we also decided to take a look at the business side of this project. An important factor here would be the amount of effort required to complete this project. In total this project took five months of FTE to complete. An estimation would be that about one month was spent on Web Component related issues, three months on Angular related issues and one month on creating JS framework wrappers, and one month on other tasks such as creating a build pipeline, package distributions etc. Note that the time taken is completely separate from the number of components in the resulting UI library, meaning an added component would not increase the time taken at all. Depending on the time required to build the UI library from scratch combined with the time taken maintaining the UI library and adding new components, this project could very well be worth it.