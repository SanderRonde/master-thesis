\chapter{Related Work}\label{chap:related-work}

There are various fields in which the related work is important to us in this paper. Namely related work in the area of UI Libraries, Angular Elements (and the accompanying process of converting to Web Components), related work on Web Components themselves, and related work on the creation of wrappers around Web Components to target JS frameworks.

\section{UI Libraries}
UI libraries are at their most basic level a set of components that follow a common design language. These components can be written in various different JS frameworks. Mr√°z \etal{}~\cite{mrazcomponent} dives into the definition of the component model, documenting the ideas behind it and how it came to be. They then discuss Web Components and their feasibility as a stand-alone replacement for current JS frameworks in component development. They find Web Components to be cumbersome to use, requiring a lot of boilerplate code (repeated sections of code with little to no variety~\cite{inproceedings}). They argue that this is the reason that other JS libraries are becoming more popular. They provide more abstraction, less boilerplate, and more ease of use. Further, they discuss two specific JS frameworks in detail, namely LitElement~\footurl{https://lit-element.polymer-project.org/guide} (an abstraction of Web Components) and React~\footurl{https://reactjs.org/} (a stand-alone library for creating components). They find them both to be capable frameworks, both filling their own niche. Finally, they not that both are essentially interoperable, with Web Components almost being natively usable in React~\footurl{https://custom-elements-everywhere.com/}.
Ky Nam \etal{}~\cite{ky2019ui} makes use of these components to build a UI library. They document the building of a UI library that uses React as a JS framework. They draw inspiration from other React UI libraries such as Material-UI~\footurl{https://material-ui.com/}, React Bootstrap~\footurl{https://react-bootstrap.github.io/}, and React virtualized~\footurl{https://github.com/bvaughn/react-virtualized}. They eventually decide to split their UI library into both a generic UI library with minimal styling (focusing on the UI) and a Core library (responsible for handling stateful components and communicating with the server). The end result meets their goals, having created a UI library that uses the aforementioned technologies.
Furthermore, there are many blog posts documenting the process of creating UI libraries. In these blog posts~\footurl{https://www.toptal.com/designers/ui/design-framework}~\footurl{https://dev.to/giteden/building-a-ui-component-library-for-your-startup-4cek}~\footurl{https://www.emergeinteractive.com/insights/detail/how-to-ux-ui-design-system-component-library/}~\footurl{https://codeburst.io/building-an-awesome-ui-component-library-in-2020-a85cb8bec20}~\footurl{https://itnext.io/building-a-scalable-ui-component-library-4607de91955a}, the authors provide guidance in setting up and creating a UI library. They mainly concern the basics, explaining how to get started with the process.
We also find numerous examples from the industry. These include but are not limited to Svelte Material UI~\footurl{https://sveltematerialui.com/} (written in Svelte), React Bootstrap~\footurl{https://react-bootstrap.github.io/} (React), Angular Material~\footurl{https://material.angular.io/} (Angular), Wired Elements~\footurl{https://wiredjs.com/} (Web Components), Onsen~\footurl{https://onsen.io/} (multi-framework), and SyncFusion~\footurl{https://www.syncfusion.com/}. For all but SyncFusion, the source code is freely available on GitHub, allowing us to draw inspiration from it and look at how various problems were solved in different UI libraries. A complete list of UI libraries can be found in Table~\ref{tab:design:ui-libraries}.

\section{Angular Elements}
Research on the area of Angular Elements is very sparse. Armengol Barahona \etal{}~\cite{armengol2020development} uses Angular Elements for the rendering of form components. They create a form component in Angular that is able to change the input elements it renders dynamically. It does this by converting Angular components to Web Components by using Angular Elements. They are then dynamically appended to the DOM. They find Angular Elements to be a good fit for this task, being easy to set up and easy to work with.
Again blog posts on Angular Elements are numerous. In various blog posts~\footurl{https://netbasal.com/understanding-the-magic-behind-angular-elements-8e6804f32e9f}~\footurl{https://medium.com/kitson.mac/wrapping-an-angular-app-in-a-custom-element-web-component-angular-element-in-4-simple-steps-ded3554e9006}~\footurl{https://medium.com/@smarth55/angular-elements-use-them-everywhere-including-your-angular-app-697f8e51e08d}~\footurl{https://blog.piotrnalepa.pl/2020/02/02/how-to-convert-angular-component-into-reusable-web-component/}~\footurl{https://medium.com/swlh/angular-elements-create-a-component-library-for-angular-and-the-web-8f7986a82999}~\footurl{https://www.thirdrocktechkno.com/blog/angular-elements/}~\footurl{https://juristr.com/blog/2019/04/intro-to-angular-elements/}~\footurl{https://studiolacosanostra.github.io/2019/07/19/Build-a-reusable-Angular-library-and-web-component/}~\footurl{https://blog.bitsrc.io/using-angular-elements-why-and-how-part-1-35f7fd4f0457}~\footurl{https://www.techiediaries.com/angular/angular-9-elements-web-components/}~\footurl{https://indepth.dev/posts/1116/angular-web-components-a-complete-guide}~\footurl{https://indepth.dev/posts/1228/web-components-with-angular-elements}, the authors explain how to set up Angular Elements and how to use it to create a new component library. These blog posts predominantly focus on creating new components or converting simple components through Angular Elements, not converting larger and more complex components. They all use new and empty projects, contrary to two other blog posts~\footurl{https://blog.nrwl.io/upgrading-angularjs-to-angular-using-elements-f2960a98bc0e}~\footurl{https://medium.com/capital-one-tech/capital-one-is-using-angular-elements-to-upgrade-from-angularjs-to-angular-42f38ef7f5fd}. The authors use Angular Elements to convert existing AngularJS (an older version of Angular) components to the newer Angular. They do this by converting the source code of existing AngularJS components to Angular source code. By itself, this would break since the application root still runs on AngularJS and is unable to handle Angular code. By using Angular Elements to convert the Angular code into Web Components, the Web Components can run inside the AngularJS root. This is thanks to the low-level nature of Web Components, allowing any framework that can render HTML elements to use them. Through this iterative process, they can convert components one by one, converting the root component once all of its children have been converted.

Unfortunately, we were unable to find any related work on the conversion of complex Angular components to Web Components through Angular Elements. Related work seems to focus primarily on small get-started style projects. When they focus on more complex projects, it seems like the only use is the conversion from AngularJS to Angular.

\section{JS Framework Wrappers}
We were unable to find any research on JS framework wrappers. JS framework wrappers do not seem to be a problem that has been tackled very often, at least in literature. On the website \emph{custom-elements-everywhere.com}~\footurl{https://custom-elements-everywhere.com/}, the authors keep track of the current usability of Web Components in various JS frameworks. Notably, the ReactJS framework does not fully support Web Components at the time of writing for this paper. In ReactJS, non-primitive values (such as Objects, Arrays, and Functions) can not be passed to Web Components, along with some other issues. As such, it is the only framework that needs a wrapper for the UI library to function at all. Looking at how to fix this issue, we find some proposed solutions in a blog post~\footurl{https://itnext.io/handling-data-with-web-components-9e7e4a452e6e}. In this blog post, the author explores various options to tackle this problem of passing non-primitive data.

\section{Metrics}\label{sec:related-work:metrics}
In Chapter~\ref{chap:design} we introduce metrics that are used to measure the quality and performance of the created Web Component library. Looking specifically at evaluating the quality of Web Components, a candidate for such a set of metrics is proposed by Martinez-Ortiz \etal{}~\cite{martinez-ortiz2016quality}. They propose a set of metrics that together give a good overview of the quality of a Web Component. These metrics are structural complexity (the number of import statements for a component), cyclomatic complexity (a quantitative measure of the number of linearly independent paths through a program's~\cite{1702388}), maintainability (a derivative based on complexity, lines of code, and Halstead volume~\cite{halstead1977elements}), completeness (how complete the information displayed to the user is as a percentage), latency (the time between when a request is made and when its content is received), and consistency (a time metric reflecting how long it takes an update to take effect across different replicas of the same component). The first three metrics are intrinsic metrics based on the source code of the Web Component. They take into account the quality of the source code. The last three metrics aim to capture the quality of a component as perceived by a user. They validate their metrics in user studies, finding that the metrics correlate strongly with the results of the user studies.

\section{Load Time}\label{sec:related-work:load-time}
A similar metric for measuring the quality of a web page is the load time. Gao \etal{}~\cite{gao2017perceived} dives into metrics that describe the load time of a page. They find that common metrics such as \emph{onLoad} and \emph{Time To First Byte} fail to accurately describe the load time as perceived by users of the page. Instead, they introduce a learning model that explains the majority of user choices with 87\% accuracy.
Similarly, Nathan \etal{}~\cite{nathan2018measuring} find that current metrics do not describe the perceived load time of a page well. They define a new metric called \emph{Ready Index}, aimed to capture interactivity explicitly. They then compare their metric to prior load time metrics, finding that they underestimate or overestimate the true load time of a page by between 24\% and 64\%.
Van Riet \etal{}~\cite{van20206} builds upon this work, also performing a case study at 30MHz in which they achieve a 97.56\% reduction in the time for the First Contentful Paint on mobile devices. The First Contentful Paint is a metric that describes the time until the first element on the page is rendered.
