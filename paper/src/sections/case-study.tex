\section{Case Study}\label{sec:case-study} \todo{Rename?}

In this section we'll first be laying out the steps taken and the issues faced during the conversion from Angular components to Web Components. We'll be splitting this section up into two subsections. The first subsection will consist of issues faced that were not specific to Angular or Angular elements, while the second subsection will contain just Angular-specific issues. Note that because of this split the issues are no longer listed out in chronological order. For a chronological overview of the various issues and their relative complexities see Table~\ref{tab:case-study:chronological-issues}. After the issue sections we'll discuss the various JS framework wrappers and how they were created. Lastly we'll be listing optimizations performed along with their effectiveness.

\begin{table}[h]
	\begin{tabularx}{\columnwidth}{X|l}
		\toprule
		\textbf{Section} & \textbf{Relative Complexity} \\ \midrule
		SC               & simple                       \\ \hline
		CC               & simple                       \\ \hline
		LOC              & simple                       \\ \hline
		MA               & simple                       \\ \hline
		RT               & simple                       \\ \hline
		SI               & simple                       \\ \hline
		LT               & simple                       \\ \hline
		NOC              & simple                       \\
	\end{tabularx}
	\caption{Sections in chronological order along with their relative complexities}
	\label{tab:case-study:chronological-issues}
\end{table}
\todo{Fill this in}

\subsection{Web Component Issues}

\subsubsection{Global CSS}
\cprotect\problemSolution{
	Angular components have a property called \code{encapsulation}\footurl{https://angular.io/guide/view-encapsulation\#view-encapsulation}. This property determines how CSS styles are applied to the component. It has three possible values:

	\begin{itemize}
		\item \emph{ShadowDom:} Global styles are not applied to the component. Only the component's own styles are applied to it.
		\item \emph{Emulated (default):} Global styles are applied to the component as well as its own styles. Other components' styles are not applied to it.
		\item \emph{None:} Global styles, a component's own styles and other components' styles are applied to this component.
	\end{itemize}

	In the 30MHz codebase the default value is used, meaning that both global and component-specific styles are applied to it. This is done by putting both of them in a global stylesheet.This stylesheet then has component-specific selectors added to it, making sure that styles are always scoped to a specific component. An example of this process can be seen in Listing~\ref{lst:case-study:component-css-source} and Listing~\ref{lst:case-study:component-css-compiled}.

	When converting the Angular components to Web Components, we ensure the components' contents are rendered within a ShadowRoot~\footurl{https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot}. This effectively separates the component from the rest of the DOM, thereby also removing the ability of the global stylesheet to be applied to it.

}{
	When a component is rendered we find the global stylesheet on the page. We then copy it into a Constructable Stylesheet~\footurl{https://developers.google.com/web/updates/2019/02/constructable-stylesheets} if it hasn't already been copied. We then use the \code{adoptedStylesheets}~\footurl{https://developers.google.com/web/updates/2019/02/constructable-stylesheets\#using_constructed_stylesheets} property of a ShadowRoot to apply the global stylesheet in the component's own ShadowRoot as well. Because this Constructable Stylesheet is just a reference to a stylesheet that the browser re-uses, the performance impact of this process is minimal compared to copying the stylesheet's source code.

}

\begin{lstlisting}[language={JavaScript},caption={The source code for a component},label={lst:case-study:component-css-source}]
// my-component.html
<my-component></my-component>

// my-component.css
:host {
	color: red;
}
\end{lstlisting}

\begin{lstlisting}[language={JavaScript},caption={An example of compiled code for the component in Listing~\ref{lst:case-study:component-css-source}.},label={lst:case-study:component-css-compiled}]
// my-component.html
<my-component _ngcontent-uix-c290></my-component>

// my-component.css
[_ngcontent-uix-c290] {
	color: red;
}
\end{lstlisting}

\subsubsection{Compatibility}
\problemSolution{
	While browser support for Web Components is fairly wide as of this case study~\footurl{https://caniuse.com/?search=components}, it is not yet universal. Additionally, Safari has chosen not to implement support for so-called \emph{Customized Built-In Elements}\footurl{https://www.chromestatus.com/feature/4670146924773376}. This feature allows for the extending of built-in HTML elements, allowing developers to extend already-existing elements such as the \code{HTMLInputElement} and others. Since the 30MHz dashboard makes use of components that extend native elements (in the form of directives\footurl{https://angular.io/guide/attribute-directives}), we need this feature to make the CC UI library work.
}{
	We add so-called polyfills to the final JS bundle. These are files that add support for unsupported features by implementing them in different ways, making use of the builtin feature if there already is support for it. In particular we use the \ver{custom-elements}\footurl{https://www.npmjs.com/package/@ungap/custom-elements} and \ver{custom-elements-builtin}\footurl{https://www.npmjs.com/package/@ungap/custom-elements-builtin} polyfills.
}

\subsubsection{Tagname renaming}
\problemSolution{
	As per the Web Components specification, all Web Components are required to have a hyphen in their tag name~\footurl{https://html.spec.whatwg.org/multipage/custom-elements.html\#custom-elements-core-concepts}. Angular components on the other hand do not have this requirement. Because of this there are some components in the 30MHz codebase without a hyphen in their name. In order to export them as Web Components we need to come up with a tag name with a hyphen in it. In this case we decided to prefix every component with \code{cow-} (for example \code{<cow-checkbox>}). However, this renaming leads to an issue with components that are being used inside other components. For example say the \code{DoubleCheckbox} component renders two checkboxes. Source code for such a component can be seen in Listing~\ref{lst:case-study:double-checkbox}. If such a component is rendered as a Web Component, it will attempt to render the \code{<checkbox>} HTML tag, not knowing that it has been renamed to \code{<cow-checkbox>}. The result is an empty component.
}{
	We run a pre-build script that replaces the names of components that are going to be used in the UI library with their prefixed variant. We make sure to not replace native HTML elements by matching the found HTML tags against a list of known native HTML elements.
}

\begin{lstlisting}[language={HTML},caption={The source code for a \code{DoubleCheckbox} component.},label={lst:case-study:double-checkbox}]
<checkbox id="checkbox-1"></checkbox>
<checkbox id="checkbox-2"></checkbox>
\end{lstlisting}

\subsubsection{Theming}
\problemSolution{
	3rd party developers have expressed the wish to apply custom theming to their apps. In order to make this possible we need to find a way to apply a single theme across all components on the page, regardless of ShadowRoots.
}{
	We make use of \emph{CSS Custom Properties}\footurl{https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties}. These are effectively CSS variables that are defined for the whole document including ShadowRoots. An example of the application of CSS Custom Properties can be seen in Listing~\ref{lst:case-study:custom-properties-js}. By changing the styles of the underlying Angular components to use CSS Custom Properties when available, we are able to provide theming. An example of this can be seen in Listing~\ref{lst:case-study:custom-properties-css}.
}

\begin{lstlisting}[language={JavaScript},caption={Applying CSS Custom Properties to the document},label={lst:case-study:custom-properties-js}]
function setPrimaryColorTheme(color: string) {
	document.documentElement.style.setProperty('color-primary', color);
}

setPrimaryColorTheme('red');
\end{lstlisting}

\begin{lstlisting}[language={CSS},caption={An example of a component making use of CSS Custom Properties},label={lst:case-study:custom-properties-css}]
my-component {
	/** 
		* Tries to use the --color-primary variable if available, 
		* falls back to blue when it is not defined.
		*/
	background-color: var(--color-primary, blue);
}
\end{lstlisting}

\subsubsection{Non-string Attributes}
\problemSolution{
	As mentioned previously, it is not possible to pass non-string attributes to Web Components using just HTML\@. This presents an issue since some Angular components expect a non-string attribute to be passed. Examples of which include but are not limited to a boolean, a number, a JavaScript object with an \code{alignment} property, and a \code{Date} instance. While this is a problem that will be solved by our JS framework wrappers and particularly in Section~\ref{sec:case-study:complex-attributes}, the CC UI library should be at least usable by itself as well.
}{
	Because in this scenario there is no access to JavaScript, we can not make use of any solutions to this problem that utilize the setting of attributes or properties through JavaScript. Instead, we need to use just HTML\@. The solution we came up with was to allow developers to optionally pass JSON to components by prefixing the attributes with \code{json-}. When this is done, the attribute value is parsed through \code{JSON.parse}, after which the corresponding property is set on the Web Component. This gives developers a way to pass most of the previously presented before. To allow developers to pass \code{Date} instances, we make it possible to pass strings, which we parse into Dates. While this is not a great workaround to have, especially since it only takes care of the \code{Date} class and not, for example, the \code{RegExp} class. The only way to fix this issue for all classes is to provide a method similar to Python \code{pickle}~\footurl{https://docs.python.org/3/library/pickle.html}, which, as mentioned on the documentation page, is not secure. We also feel like this problem is not prevalent enough in our case to warrant such a solution. Currently, all occurrences of classes as Angular component inputs have been taken care of.
}

\subsubsection{Complex Attributes}
\label{sec:case-study:complex-attributes}
\problemApproachesImplementation{
	Continuing on with the same problem, we now need to come up with a way to solve the problem for even more situations, this time being able to make use of JavaScript since solution will be implemented into the JS framework wrappers. Some of which include the passing of an object reference or an HTML element reference. This will never be possible through JSON since the reference needs to be preserved. Instead, we make use of JavaScript this time. Our goal is to allow a parent component written in the language of the JS framework to be able to pass its properties down to its child. This parent component is essentially just a passthrough component whose set of properties is identical. Its only purpose is to pass on these components and to provide a component native to the JS framework. Another thing to keep in mind is the fact that we need all properties to be defined before the child component performs its first render. This issue is present simply because of the way the original Angular components are written, assuming that they will only receive attributes once and that they'll never change.
}{
	There are a few approaches to solving this issue, these can be grouped into three categories.

	\begin{itemize}
		\item \emph{Parent \(\rightarrow\) child:} The parent node gets a reference to the child during the rendering process. Then the parent sets the properties on the child.
		\item \emph{Child \(\rightarrow\) parent:} The child gets a reference to the parent during the rendering process. It then requests its properties from the parent.
		\item \emph{Parent \(\rightarrow\) intermediary \(\rightarrow\) child, Child \(\rightarrow\) intermediary \(\rightarrow\) parent:} An intermediary takes the properties from the parent. The parent then provides the child with some way to find the intermediary, after which the child can get the properties from the intermediary upon rendering.
	\end{itemize}

	The first approach would be the easiest, however, this approach is not always possible. Many JS frameworks do not provide such low-level access to the to-be-rendered component. Instead, they often provide callbacks with a reference to the element after it has been connected to the DOM\@. Since the properties of our components need to be defined before they've even been rendered, this approach does not work for us.

	The second approach presents similar problems. While in some JS frameworks it is possible to get a reference to the parent component, JS frameworks that use a virtual DOM such as React and Vue~\footurl{https://vuejs.org/} do not have a real parent component instance. Instead, the parent is just an abstract concept.

	This leaves us with the last approach. The creation of an intermediary object which holds the properties. The child is then given some way to get a reference to the intermediary (bypassing the problem of the second approach), after which it can get the to-be-applied properties from the intermediary. As long as we make sure the child has a way to find the intermediary access before it has been rendered to the DOM, we are able to fulfill the requirement of defining all properties before the first render.
}{
	Our implementation consists of a number of steps. We start off by creating a class which we'll call \emph{Intermediary}. This class has an instance manager attached to it which we'll call the \emph{IntermediaryManager}. Our JS framework wrapper code will be wrapping around the basic CC UI library. Since the CC UI library does not export the IntermediaryManager, we're unable to get a reference to it from our wrapper (aka the parent). In order to still get a reference to it, we want to store it globally. Because storing such properties on the \code{window} object can result in collisions and is unreliable, we'll be storing it as a property of the defined Web Components. This means that we're able to call \code{customElements.get('cow-checkbox').IntermediaryManager} and get a reference to the IntermediaryManager from both the parent side and the child side.

	Now that we've taken care of this issue, we're able to start using it. We make the parent create an instance of an Intermediary. This Intermediary gets a simple string ID\@. We are then able to look up the ID in the IntermediaryManager and get the corresponding Intermediary. This ID is passed to the child, allowing it to look up this Intermediary.

	For passing the actual values we make use of references. For each of the parent's properties, we pass the value to the Intermediary. The Intermediary then generates a unique string representing that value. If the value is already known by the Intermediary, the same string is returned. Internally it maps this string to the value. We then pass this string to the child instead of passing the original complex value (which would not work). The child then receives the value and resolves it back to a complex value by consulting the Intermediary. Through this process the child component is able to receive complex values from its parent through simple HTML string attributes.
}

\subsection{Angular Issues}
\subsubsection{ng-deep}
\problemSolution{
	Angular provides the \code{ng-deep} CSS selectors~\footurl{https://angular.io/guide/component-styles\#deprecated-deep--and-ng-deep}. Where regular CSS selectors stop at the ShadowDom boundary, meaning that a component will never be able to have a selector apply to the DOM of another component, the ng-deep selector does allow for this. It is an emulated and deprecated selector that does not work outside of Angular environments (including the Web Components environment). As such we need to remove it.
}{
	The fix for this issue was fairly simple. Any instance of ng-deep had to be removed. While there has been some talk around browser support for a similar deep selector~\footurl{https://drafts.csswg.org/css-scoping/}, with both \code{::shadow} and \code{/deep/} making it into Chrome, they have since both been removed~\footurl{https://developers.google.com/web/updates/2017/10/remove-shadow-piercing}. As such, we had to come up with a workaround. Since the only way to effectively communicate from a component to child components is properties, we changed the code to use properties instead. An example of this change can be seen in Listing~\ref{lst:case-study:ng-deep-before} and Listing~\ref{lst:case-study:ng-deep-after}.
}

\begin{lstlisting}[language={JavaScript},caption={A component before the ng-deep change},label={lst:case-study:ng-deep-before}]
// parent-component.html
<child-component></child-component>

// parent-component.css
::ng-deep div {
	color: red;
}

// child-component.ts
@Component({
	...
})
class ChildComponent {
	...
}
\end{lstlisting}

\begin{lstlisting}[language={JavaScript},caption={A component after the ng-deep change},label={lst:case-study:ng-deep-after}]
// parent-component.html
<child-component red></child-component>

// parent-component.css
/**
 * ::ng-deep div {
 * 	color: red;
 * }
*/

// child-component.ts
@Component({
	...
})
class ChildComponent {
	@Input() red: boolean;

	constructor(private _elementRef: ElementRef) {
		if (this.red) {
			_elementRef.nativeElement.classList.add('red');
		}
	}
}

// child-component.css
:host[red] {
	color: red;
}

\end{lstlisting}

\subsubsection{createCustomElement}
\problemSolution{
	The main export of the Angular Elements library is the \code{createCustomElement} function~\footurl{https://angular.io/api/elements/createCustomElement}. This function takes an Angular component and turns it into a Web Component. It does this by extending an \code{HTMLElement} base class and applying all Angular component features on top of it. However, this function does not offer the ability to change the base class from an \code{HTMLElement} into anything else. As mentioned before, the 30MHz dashboard makes use of some elements that extend native elements. For example the 30MHz input field extends the default HTML input field and only adds styling, preserving any builtin accessibility features provided by the browser. When converting this Angular component to a Web Component, we also wish to preserve these same features. This can be done by extending builtin HTML elements~\footurl{https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements}. However, the \code{createCustomElement} function does not provide this option, causing us to be unable to create such an element. There is an open feature request for this option at the time of writing of this paper~\footurl{https://github.com/angular/angular/issues/19108}.
}{
	We have no choice but to implement this option ourselves. This means we have to copy the entire source code of the \code{createCustomElement} function, along with many of its dependencies since very few of them are exported. After this we change the function to allow us to pass such an option.
}

\subsubsection{EventEmitters}
\problemSolution{
	Angular implements so-called \code{EventEmitters}~\footurl{https://angular.io/api/core/EventEmitter}. These are classes that are able to emit events, as well as being able to be listened to. When the \code{emit} function is called, the passed value is sent directly to those functions that added an event listener to it. Note that this behavior is different from regular event emitters, which emit a \code{CustomEvent}, which contains the actual value in the \code{detail} property. A lot of our Angular code relies on the value being directly emitted, and it not being wrapped in a CustomEvent.

	When a component is converted to a Web Component however, this emitted value is wrapped in a CustomEvent. Since the Angular code relies on this value being directly emitted, errors occur. In order to get around this issue, we need to make sure that internal code that listens to such EventEmitters receives the value itself, while external code (such as a 3rd party listening to a Web Component) receives the value wrapped in a CustomEvent.
}{
	We run a script that iterates over the source files, looking for any location where an event listener is being added to such an EventEmitter. Once we find one, we wrap the callback in an unwrapping function that strips away the CustomEvent and returns just the \code{code} value. An example of this change can be seen in Listing~\ref{lst:case-study:event-handler-change}.
}

\begin{lstlisting}[language={JavaScript},caption={A change made to an event listener. The definition of \code{unwrapEvent} can be seen in Listing~\ref{lst:case-study:event-handler-unwrap-event}},label={lst:case-study:event-handler-change}]
// before
(valueChanged)="myHandler($event)"

// after
(valueChanged)="myHandler(unwrapEvent($event))"
\end{lstlisting}

\begin{lstlisting}[language={JavaScript},caption={The \code{unwrapEvent} function},label={lst:case-study:event-handler-unwrap-event}]
function unwrapEvent(event) {
	if (event instanceof CustomEvent) {
		return event.detail;
	}
	return event;
}
\end{lstlisting}

\subsubsection{Hierarchical Injectors}
\problemSolution{
	Angular makes use of a feature called \emph{Dependency Injection}~\footurl{https://angular.io/guide/dependency-injection}. This allows a parent module to provide its children with an instance of a certain dependency class. This class instance is shared among the module and its children. Generally only modules provide their children with dependencies, where modules are simply collections of components that serve some common purpose. However, this dependency injection feature can also be leveraged to have a given component provide its own instance of a class only to its direct children. This means that every instance of that component gets its own separate instance of the dependency, which it then shares with its children, and not one that is shared across all components in the module. This is called \emph{Hierarchical Dependency Injection}\footurl{https://angular.io/guide/hierarchical-dependency-injection} and it is a feature that is utilized by 30MHz in some areas.

	Angular Elements does not support this feature intentionally~\footurl{https://github.com/angular/angular/issues/24824\#issuecomment-404399564}. Instead, it only supports the use case where modules provide their components with dependencies. The reason for this is that every component converted with Angular Elements is mounted to the DOM as its own root. It does not have a concept of a parent component, and as such is unable to look up the injector of its parent. While the pattern of Hierarchical Dependency Injection is not recommended~\footurl{https://github.com/angular/angular/issues/24824\#issuecomment-404399564}, it is still a pattern used by 30MHz, and as such one we need to support in order for the CC UI library to work.
}{
	Our goal in fixing this problem is to have a component injector inherit from its parent injector, which will facilitate Hierarchical Dependency Injection. To do this, we need to find the parent when the child is being rendered. After this, we can extract its injector, craft a new injector that combines the child and parent injector, and finally supply this new injector to the child. An example of this process can be found on StackBlitz~\footurl{https://stackblitz.com/edit/ngelements-issue-40104?file=src\%2Fapp\%2Fbar\%2Fbar.component.ts}.

	We first need to find the parent. This process is fairly straightforward. When the child is being rendered, we simply travel up the DOM tree until we find a node that has certain properties that only Angular elements have. We then move on to the next stage of finding its injector.

	While the finding of a node's injector is very simple in development mode since Angular exposes a \code{window.ng.getInjector} function, this process is a lot more complicated in production mode. To find it we first need to find the component's hidden Angular properties. These can be found under the component's \code{\_\_ngContext\_\_} property. Depending on the environment, this can either be an object containing the so-called \code{tNode} and \code{lView} properties or an array that contains them at a magic offset. The \code{tNode} and \code{lView} are internal representations of a bunch of Angular-specific properties for the component.

	We are unable to access the original injector of the parent component since it is hidden in Angular-internal code. Instead we need to use the \code{tNode} and \code{lView} to craft a new injector that will do the same thing as the original injector. However, in order to craft this new injector class instance we need a reference to that very class. While a \code{Injector} class is exported from the Angular package, this is not actually the injector we want. Angular actually has two types of injector, one of which is the previously mentioned \code{Injector} and the other is the so-called \code{NodeInjector}. This \code{NodeInjector} is only used internally, and it is the injector we want. To get a reference to it, we access the \code{injector} property of a fake component created by a \code{ComponentFactory}. Since the \code{ComponentFactory} is also not exported, we need to get a reference to it through the global injector. We now finally have a reference to the \code{NodeInjector} class, which allows us to re-create the parent's injector.

	We now merge this injector with the child injector. This is a fairly simple process. When a request for an injected value comes in we first look for it in the child. If the child does not have it, we look at the parent injector.

	We now need to make sure Angular actually uses this injector we just created. To do so, we need to override the component's default element strategy (\code{NgElementStrategy}). This element strategy is a class provided by Angular that manages the connection between the DOM and the underlying Angular component. Since the \code{NgElementStrategy} class is also not exported by Angular, we need to find a reference to it somewhere. To do so, we create a fake component and read its \code{ngElementStrategy} property. We can now extend the class, replace the injector and provide it to the component. A full code example of this process can be found in Listing~\ref{lst:appendix:hierarchical-injectors}.
}

\subsubsection{ngOnInit}
\problemSolution{
	Angular Elements does intentionally not guarantee the order in which attributes are set on an element (even initial attributes)~\footurl{https://github.com/angular/angular/issues/29050}. This means that attributes can be set on an element both before or after its main init hook (\code{ngOnInit}) is called. An example of this process can be seen in Listing~\ref{lst:case-study:ng-on-init}. While this isn't a problem if attributes are only used to handle visual state, this can cause great problems when they are used for component configuration. For example if a component performs a fetch request to the server and takes a \code{URL} property that determines the target URL, it is essential that this property is set before the component's main hook runs. Quite a few components in the 30MHz codebase have a similar setup. As such, we need to guarantee that a component will always have the full set of initial properties set before its main hook is called.
}{
	We know that, while the order of attribute setting is not guaranteed, we are guaranteed the fact that they will run sequentially. Since JavaScript is a single-threaded language and all attribute setting calls are synchronous, we know that all attributes will be set once the main thread is free again. For this we use the global \code{window.requestAnimationFrame} JavaScript function. This function takes a callback and calls it when the main JavaScript thread is free to take on new work. We now firstly replace the component's \code{ngOnInit} function with an empty function, ensuring that when Angular calls it, the component's main hook is not actually ran. We then call \code{window.requestAnimationFrame} and pass it the original \code{ngOnInit} function. Now we can guarantee that the \code{ngOnInit} function is called after all attributes have been set.
}

\begin{lstlisting}[language={JavaScript},caption={HTML source code and its Angular Elements equivalent},label={lst:case-study:ng-on-init}]
// HTML source file
<my-element foo="bar" bar="baz" />

// can be transformed into any of the following:
// 1
const element = document.createElement('my-element');
element.setAttribute('foo', 'bar');
element.setAttribute('bar', 'baz');
parent.appendChild(element);

// 2
const element = document.createElement('my-element');
parent.appendChild(element);
element.setAttribute('foo', 'bar');
element.setAttribute('bar', 'baz');

// 3
const element = document.createElement('my-element');
element.setAttribute('foo', 'bar');
parent.appendChild(element);
element.setAttribute('bar', 'baz');
	\end{lstlisting}

\subsubsection{Casing in attribute names}
\problemSolution{
	In the process of converting Angular components to Web Components, Angular Elements maps all input properties from camelCase casing to kebab-case. For example the input property \code{myInputProperty} is set through the \code{my-input-property} HTML attribute. The reason for this change is that HTML attributes are case-insensitive. To HTML \code{myInputProperty} is identical to \code{myinputproperty} and \code{MYINPUTPROPERTY}. While this is a good change to make, and one that ensures that name collisions are less likely to happen, it does present some issues. Internal Angular elements still use the camelCase variant to set properties on their child components. Since the Web Component variants do not recognize the camelCase variant of the property anymore, they are ignored.
}{
	We solve this issue by making sure the Web Components also accept the camelCase variant. As HTML is case insensitive there is no point in checking the casing of the passed attribute. Instead, we convert it to lowercase and compare it against the lowercase version of the original camelCase input property. In the previous example \code{myInputProperty}, \code{myinputproperty}, \code{MYINPUTPROPERTY}, and \code{my-input-property} would all refer to the input property \code{myInputProperty} on the Angular component.
}

\subsubsection{Angular directives}
\problemSolution{
	Angular has two types of elements that appear in the DOM\@. The first type is the Component, which looks for a given selector or tag name and replaces the original HTML element. For example an \code{AppRootComponent} with the selector \code{'app-root'} will look for an \code{<app-root>} HTML element and replace it with the Angular component instance. The second type is the Directive. Similarly, this look for a selector, but instead of replacing the original HTML element, this simply mounts to it and runs its own code on it. An example of this would be a \code{Blink} directive that looks for the \code{'blink'} HTML class. When mounted it periodically hides and un-hides the component.

	Angular Elements only supports the conversion of Components to Web Components, not the conversion of Directives. Since there are some elements in the 30MHz codebase that use Directives, we need to make sure that these are supported as well.
}{
	While this might sound like a tough problem since these are entirely different elements, the fix for this issue is surprisingly easy. Under the hood Angular stores the definition of a Component in the \code{\cmcrv{}cmp} property. This is also the property Angular Elements accesses to do the conversion from Angular components to Web Components. Similarly, the definition of Directives is stored in the \code{\cmcrv{}dir} property. By simply copying the value of the \code{\cmcrv{}dir} property to the \code{\cmcrv{}cmp} property, we are able to trick Angular Elements into thinking a directive is a component. Surprisingly, this actually works and the directive works perfectly.
}

\subsubsection{<ng-content>}
\problemSolution{
	Angular uses the \code{<ng-content>} tag for so-called content projection. Content projection is the ability for a component to take a set of children, which it can then place anywhere in its DOM tree. This is effectively the same as the HTML \code{<slot>} tag~\footurl{https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot}. An example of content projection can be seen in Listing~\ref{lst:case-study:ng-content}. Content projection works fine in most scenarios but sometimes it does not work. The child elements simply do not show up.
}{
	Our solution is once again quite simple, we take advantage of the fact that the \code{<ng-content>} and \code{<slot>} tag do the same thing and append a \code{<slot>} tag to every occurrence of an \code{<ng-content>} tag in the source code. This ensures that when the \code{<ng-content>} tag does not work, the \code{<slot>} tag takes over instead.
}


\begin{lstlisting}[language={HTML},caption={HTML source code and its Angular Elements equivalent},label={lst:case-study:ng-content}]
// parent-component.html
<child-component>
	<span id="my-span"></span>
</child-component>

// child-component.html
<div id="my-root">
	<ng-content></ng-content>
</div>

// Effective DOM tree
<parent-component>
	<child-component>
		<div id="my-root">
			<span id="my-span"></span>
		</div>
	</child-component>
</parent-component>
	\end{lstlisting}

\subsection{JS Framework Wrappers}
\todo{}

\subsection{Optimizations}
\todo{}