\chapter{Introduction}
The practice of providing app developers with a design language to use for their app is a common one, being applied in both Google's Android~\footurl{https://material.io/}, Apple's iOS~\footurl{https://developer.apple.com/design/}, and Zendesk's Garden~\footurl{https://garden.zendesk.com/}. In order to aid developers in creating apps that use this design language, they are often provided with a set of basic components that follow this design language. Examples of which include buttons, inputs, layouts, and switches. Such a set of components is commonly called a UI library or design library. Since the design language a company provides is generally applied to its own products as well, the overlap between its provided UI library and its internally used UI library is relatively large. As such, it would save a lot of time if the UI library that is provided to third parties can be generated from the internally used UI library (given that it can not be provided to developers as-is).

An example of such a scenario is one that is present at 30MHz. 30MHz is a technology company in the agriculture industry looking to provide third parties with a UI library. To save time, both now and in future maintenance, it would be best to generate this UI library from the internally used UI library. This UI library is unable to provided to third parties as-is. Both because it is interwoven with the rest of the code base (which should not become publicly available) and because it is written in Angular~\footurl{https://angular.io/}.

Angular is a JavaScript (JS) framework for building single-page web applications. Angular is one of many JS frameworks. A few of the most popular JS frameworks as of 2020~\footurl{https://2020.stateofjs.com/en-US/technologies/front-end-frameworks/} include React JS~\footurl{https://reactjs.org/}, Vue~\footurl{https://vuejs.org/}, Svelte~\footurl{https://svelte.dev/}, and the previously mentioned Angular. The problem with 30MHz using a JS framework such as Angular is that code written in one framework is generally not usable by other frameworks. They are essentially written in different programming languages. Locking third-party developers to a single JS framework (in this case Angular) will provide for a worse development experience. Since the popularity of other JS frameworks is increasing, this problem is likely to worsen over time. To get around both the issue of the code being interwoven and the issue of the source code being written in Angular, a solution to these problems has to be devised.

In this thesis, we attempt to find this solution through a case study at 30MHz. Our approach is to convert the existing Angular components to Web Components~\footurl{https://www.w3.org/TR/2013/WD-custom-elements-20130514/\#about}. Web Components are a way of defining custom HTML elements. Similar to components in JS frameworks, Web Components allow for compartmentalization of functionality. The difference with JS frameworks is that Web Components are native to web browsers, being supported by all major browsers since 2018~\footurl{https://caniuse.com/?search=webcomponents}. Web Components were introduced with the idea of providing a common format in which components can be provided and used. For example a developer might make a chart Web Component, open source it and provide it to other developers. Other developers can now use this chart in their application. If the chart were written in a JS framework, it would most likely only work in other apps using that specific JS framework. Web Components on the other hand work are supported in most JS frameworks~\footurl{https://custom-elements-everywhere.com/} and can be used in almost every web application.

Because of their being usable by every JS framework, Web Components provide a perfect target format for our UI library. In order to convert the Angular components to Web Components we will be using Angular Elements~\footurl{https://angular.io/guide/elements}. Angular Elements is a JS package that allows for the conversion of Angular components to Web Components. After creating this Web Component UI library, we will be creating wrappers for JS frameworks that do not natively support Web Components yet. Additionally, we will be generating documentation and individual component demo pages for developers.

In this paper we will be describing this process and evaluating its effectiveness. This evaluation will be done through the collection of various metrics. These will be collected on both the original Angular components, the Web Components library and the various wrappers, as well as a set of popular JS component libraries. We will then compare the created Web Components library to the internal 30MHz UI library and other component libraries in the field, allowing us to assess the feasibility of this conversion process.

The contributions in this paper are the following:

\begin{itemize}
	\item A case study where we perform the conversion of Angular components to Web Components is presented, documenting issues faced along the way. Theses issues are likely to be faced in similar projects.
	\item The quality and performance of the resulting Web Component UI library and its wrappers is evaluated. In order to evaluate the impact of this conversion process on performance we will be comparing the Web Component UI library with the original UI library. Additionally, we will be comparing the Web Component UI library with other UI libraries in the field, allowing us to evaluate its relative performance and quality.
	\item The feasibility of applying this conversion process for businesses is evaluated. Firstly we will measure the time taken to perform this case study, getting an understanding of the cost of the case study. Secondly, we will be assessing the impact on both the existing code base and other developers we get a view of how disrupting this project is.
	\item A GitHub repository that contains the code used for performing the measurements is provided~\footurl{https://github.com/sanderronde/master-thesis}. Additionally it contains the resulting data, visualizations, and the code used to generate these visualizations.
\end{itemize}