\chapter{Introduction}
Web Components~\footurl{https://www.w3.org/TR/2013/WD-custom-elements-20130514/\#about} are a set of technologies recently added to the web platform that allow for the definition of custom HTML elements. The creation of custom HTML elements allows for encapsulation of functionally and semantically related code. In this purpose, these Web Components are similar to JavaScript (JS) frameworks such as React JS~\footurl{https://reactjs.org/}, Angular~\footurl{https://angular.io/}, Svelte~\footurl{https://svelte.dev/}, and Vue~\footurl{https://vuejs.org/}. What separates Web Components from JS frameworks is the fact that Web Components are native to web browsers and do not require external code to function. As of 2018, Web Components are supported by all major browsers~\footurl{https://caniuse.com/?search=webcomponents}, marking the moment at which Web Components are supported across all platforms and browsers without any additional code being required. This places Web Components in a special position where any individual Web Component can be added to a web page with the guarantee that it will work. This inter compatibility allows developers to create a single Web Component ranging from simple components such as buttons and checkboxes to complex components such as charts and video players. This is in contrast to components that are created using a JS framework. These will generally only work if the component's framework is the same framework the web page uses. This lack of compatibility significantly reduces the pool of components that developers have access to, thereby reducing the community's ability to share code in the form of components with each other.

One solution to this problem is providing the ability to migrate components that have been written in a JS framework to Web Components. This effectively frees developers from the constraints of a JS framework and allows Web Components to be used anywhere. There are various reasons to migrate a component (or multiple components) to Web Components. An example is the ability to have the same components be re-used across different teams that each use a different JS framework. Another example is the ability to provide created components to the open-source community, thereby allowing other developers to make use of these components. In this paper, we present a case study targeting another reason for this migration process, namely the migration of a design library to Web Components. This reason is introduced below.

\section{Reason for migrating to Web Components}
Many companies apply a unified design language to their products. A design language is an overarching style that guides the design of products it applies to, generally being spread over a company's products. Its purpose is to provide users of products with a unique but consistent look and feel across all products. In order to maintain this design language across apps created on their platform, companies tend to provide third-party app developers with such a design language to use for their apps. Examples of such a design language being provided to developers are Google's Android~\footurl{https://material.io/}, Apple's iOS~\footurl{https://developer.apple.com/design/}, and Zendesk's Garden~\footurl{https://garden.zendesk.com/}. In order to aid developers in creating apps that use this design language, they are often provided with a set of basic components that follow this design language. Examples of UI components include buttons, inputs, layouts, and switches. Such a set of components is commonly called a UI library or design library. In addition to containing just UI-related components, these UI libraries can also contain components that focus on for example API access, accessibility, or analytics. Since the design language a company provides is generally applied to its own products as well, the overlap between its provided UI library and its internally used UI library is relatively large. As such, it would save a lot of time if the UI library that is provided to third parties can be generated from the internally used UI library (given that it can not be provided to developers as-is).

An example of such a scenario is one that is present at 30MHz. 30MHz is a technology company in the agriculture industry looking to provide third parties with a UI library. To save time, both now and in future maintenance, it would be best to generate this UI library from the internally used UI library. This UI library is unable to be provided to third parties as-is. Both because it is interwoven with the rest of the codebase (which should not become publicly available) and because it is written in the Angular JS framework.

Angular is a JS framework for building single-page web applications. Angular is one of many JS frameworks. A few of the most popular JS frameworks as of 2020~\footurl{https://2020.stateofjs.com/en-US/technologies/front-end-frameworks/} include React JS, Vue, Svelte, and the previously mentioned Angular. As mentioned before, code written in one framework is generally not usable by other frameworks. They are essentially written in different programming languages. Locking third-party developers to a single JS framework (in this case, Angular) will provide for a worse development experience. Since the popularity of other JS frameworks is increasing, this problem is likely to worsen over time. To get around both the issue of the code being interwoven and the issue of the source code being written in Angular, a solution to these problems has to be devised.

In this thesis, we attempt to find this solution through a case study at 30MHz. Our approach is to migrate the existing Angular components to the previously mentioned Web Components~\footurl{https://www.w3.org/TR/2013/WD-custom-elements-20130514/\#about}. Because of their being usable by every JS framework, Web Components provide a perfect target format for this UI library. In order to migrate the Angular components to Web Components, we use Angular Elements~\footurl{https://angular.io/guide/elements}. Angular Elements is a JS package that allows for the migration of Angular components to Web Components. After creating this Web Component UI library, we create wrappers for JS frameworks that do not natively support Web Components yet. Additionally, we generate documentation and individual component demo pages for developers.

In this paper, we describe this process and evaluating its effectiveness. This evaluation is done through the collection of various metrics. These are collected on both the original Angular components, the Web Components library, and the various wrappers, as well as a set of popular JS component libraries. We then compare the created Web Components library to the internal 30MHz UI library and other component libraries in the field, allowing us to assess the feasibility of this migration process.

The contributions of this paper are the following:

\begin{itemize}
	\item A case study where we perform the migration of Angular components to Web Components is presented, documenting issues faced along the way. These issues are likely to be faced in similar projects.
	\item We present a checklist going over the steps required to perform this migration.
	\item We evaluate the quality and performance of the resulting Web Component UI library and its wrappers. In order to evaluate the impact of this migration process on performance, we compare the Web Component UI library with the original UI library. Additionally, we compare the Web Component UI library with other UI libraries in the field, allowing us to evaluate its relative performance and quality.
	\item The feasibility of applying this migration process for businesses is evaluated. Firstly we measure the time taken to perform this case study, getting an understanding of the cost of the case study. Secondly, we assess the impact on both the existing codebase and other developers we get a view of how disrupting this project is.
	\item A GitHub repository that contains the code used for performing the measurements is provided~\footurl{https://github.com/sanderronde/master-thesis}. Additionally, it contains the resulting data, visualizations, and the code used to generate these visualizations.
\end{itemize}